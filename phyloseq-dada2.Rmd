---
title: "Phyloseq-state-dada"
output:
  github_document:
  toc: true
  toc_depht: 2
---

```{r}
library(knitr)
library(markdown) 
```

#Importer directement les tables produites par le pipeline DADA2 dans phyloseq. Nous ajouterons également la petite quantité de métadonnées dont nous disposons - les échantillons sont nommés par le sexe (G), le numéro de sujet de la souris (X) et le jour après le sevrage (Y) où ils ont été échantillonnés (par exemple GXDY).

```{r}
packageVersion("phyloseq")
```
Le package phyloseq R est un cadre puissant pour une analyse plus approfondie des données sur le microbiome . 



```{r}
BiocManager::install("Biostrings")
```
le package biostring a une fonctionnalité pour la correspondance de motifs (alignement de lecture courte) ainsi qu'une fonction d'alignement par paires


```{r}
packageVersion("Biostrings")
```

```{r}
BiocManager::install("ggplot2")
```


Le package ggplot2 est un système de création graphique déclarative, basé sur The Grammar of Graphics . Vous fournissez les données, dites à ggplot2 comment mapper des variables à l'esthétique, quelles primitives graphiques utiliser et il s'occupe des détails
```{r}
packageVersion("ggplot2")
```

#Ca permets de voir si le package est bien installer
```{r}
library("phyloseq")
```


```{r}
library("Biostrings")
```


```{r}
library("ggplot2")
```


#construire un échantillon simple à data.framepartir des informations encodées dans les noms de fichiers: maintenant on regroupe tout dans un objet phyloseq avec la commande ps (arbre phylo, table de données etc…) exemple de l’armoire et des tiroirs. On va créer nos outils pour l’analyse de phyloseq


#Constriure un objet phyolseq
```{r}
ps_connect <-url("https://raw.githubusercontent.com/spholmes/F1000_workflow/master/data/ps.rds")
ps = readRDS(ps_connect)
ps
```

#Créeation d'un tableau des nombres de lectures pour chaque phylum présent dans l'ensemble de données.
## Show available ranks in the dataset
```{r}
rank_names(ps)
```
# Create table, number of features for each phyla
```{r}
table(tax_table(ps)[, "Phylum"], exclude = NULL)
```
On a quelques phylums pour lesquels une seule caractéristique a été observée. Cela vaut peut-être la peine d'être filtré, et nous vérifierons cela ensuite. Tout d'abord, notez que dans ce cas, six caractéristiques ont été annotées avec un Phylum of NA. Ces fonctionnalités sont probablement des artefacts dans un ensemble de données comme celui-ci et doivent être supprimées.

#garantir que les fonctionnalités avec une annotation de phylum ambiguë sont également supprimées. Notez la flexibilité dans la définition des chaînes qui doivent être considérées comme des annotations ambiguës.

```{r}
ps <- subset_taxa(ps, !is.na(Phylum) & !Phylum %in% c("", "uncharacterized"))
```

#Explorer la prévalence des caractéristiques dans l'ensemble de données, que nous définirons ici comme le nombre d'échantillons dans lesquels un taxon apparaît au moins une fois.

```{r}
# Compute prevalence of each feature, store as data.frame
prevdf = apply(X = otu_table(ps),
               MARGIN = ifelse(taxa_are_rows(ps), yes = 1, no = 2),
               FUN = function(x){sum(x > 0)})
# Add taxonomy and total read counts to this data.frame
prevdf = data.frame(Prevalence = prevdf,
                    TotalAbundance = taxa_sums(ps),
                    tax_table(ps))
```


#Calcule rles prévalences totales et moyennes des caractéristiques dans chaque phylum pour voir est-ce qu'il y a des phylums composés principalement de caractéristiques à faible prévalence.
```{r}
plyr::ddply(prevdf, "Phylum", function(df1){cbind(mean(df1$Prevalence),sum(df1$Prevalence))})
```
Seulement plus de 1% des échantillons contenaient de Deinococcus-Thermus et seulement 2 échantillons contenaient du Clostridium. Dans certains cas, malgré cela, il peut être intéressant d'étudier ces deux portes plus en détail (mais il peut ne pas s'agir de deux échantillons de Fusobacteria). Cependant, aux fins de cet exemple, ils seront filtrés hors de l'ensemble de données.


# Define phyla to filter
```{r}
filterPhyla = c("Fusobacteria", "Deinococcus-Thermus")
# Filter entries with unidentified Phylum.
ps1 = subset_taxa(ps, !Phylum %in% filterPhyla)
ps1
```
#Filtrage de la prévalence
## Les étapes de filtrage précédentes sont considérées comme supervisées.Cette prochaine étape de filtrage est complètement non supervisée , ne reposant que sur les données de cette expérience et sur un paramètre que nous choisirons après avoir exploré les données.
```{r}
# Subset to the remaining phyla
prevdf1 = subset(prevdf, Phylum %in% get_taxa_unique(ps1, "Phylum"))
ggplot(prevdf1, aes(TotalAbundance, Prevalence / nsamples(ps),color=Phylum)) +
  # Include a guess for parameter
  geom_hline(yintercept = 0.05, alpha = 0.5, linetype = 2) +  geom_point(size = 2, alpha = 0.7) +
  scale_x_log10() +  xlab("Total Abundance") + ylab("Prevalence [Frac. Samples]") +
  facet_wrap(~Phylum) + theme(legend.position="none")
```

Chaque point de la figure est une unité de taxonomie différente. Parcourir les données de cette manière est souvent utile pour sélectionner les paramètres de filtre, tels que les critères de prévalence minimale qui ont utilisés pour filtrer les données ci-dessus. Aucune séparation naturelle n'est immédiatement évidente, mais il semble que l'on puisse raisonnablement fixer le seuil de prévalence à environ zéro à dix pour cent. Notez que cette sélection n'introduit pas de biais dans l'analyse en aval de la corrélation d'abondance de biais.

#Utiliser cinq pour cent de tous les échantillons comme seuil de prévalence
```{r}
# Define prevalence threshold as 5% of total samples
prevalenceThreshold = 0.05 * nsamples(ps)
prevalenceThreshold
```

```{r}
# Execute prevalence filter, using `prune_taxa()` function
keepTaxa = rownames(prevdf1)[(prevdf1$Prevalence >= prevalenceThreshold)]
ps2 = prune_taxa(keepTaxa, ps)
```

#Filtrage de la prévalence
##Montrer comment combiner toutes les fonctionnalités qui descendent du même genre.
```{r}
# How many genera would be present after filtering?
length(get_taxa_unique(ps2, taxonomic.rank = "Genus"))
```

```{r}
ps3 = tax_glom(ps2, "Genus", NArm = TRUE)
```
Si la taxonomie n'est pas disponible ou n'est pas fiable, l'agglomération arborescente est une alternative «sans taxonomie» pour combiner des caractéristiques de données correspondant à des taxons étroitement liés. Dans ce cas, plutôt que le rang taxonomique, l'utilisateur spécifie une hauteur d'arbre correspondant à la distance phylogénétique entre les entités qui doivent définir leur regroupement. Ceci est très similaire au «clustering OTU», sauf que dans de nombreux algorithmes de clustering OTU, la distance de séquence utilisée n'a pas la même (ou aucune) définition évolutive.




```{r}
h1 = 0.4
ps4 = tip_glom(ps2, h = h1)
```
Ici, la plot_tree()fonction de phyloseq compare les données originales non filtrées, l'arbre après l'agglomération taxonoïque et l'arbre après l'agglomération phylogénétique. Ceux-ci sont stockés en tant qu'objets de tracé séparés, puis rendus ensemble dans un graphique combiné à l'aide de gridExtra::grid.arrange.

```{r}
multiPlotTitleTextSize = 15
p2tree = plot_tree(ps2, method = "treeonly",
                   ladderize = "left",
                   title = "Before Agglomeration") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p3tree = plot_tree(ps3, method = "treeonly",
                   ladderize = "left", title = "By Genus") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
p4tree = plot_tree(ps4, method = "treeonly",
                   ladderize = "left", title = "By Height") +
  theme(plot.title = element_text(size = multiPlotTitleTextSize))
```



```{r}
library ("gridExtra") 
grid.arrange(nrow = 1, p2tree, p3tree, p4tree)
```

La figure montre l'arbre d'origine sur la gauche, la classification est groupée au niveau du genre moyen et le cluster phylogénétique est à une distance fixe de 0,4



#Transformation de la valeur d'abondance
##définir une fonction de tracé personnalisée plot_abundance(),, qui utilise la fonction de phyloseq pour définir un graphique d'abondance relative. Nous l'utiliserons pour comparer plus facilement les différences d'échelle et de distribution des valeurs d'abondance dans notre objet phyloseq avant et après transformation.
```{r}
plot_abundance = function(physeq,title = "",
                          Facet = "Order", Color = "Phylum"){
  # Arbitrary subset, based on Phylum, for plotting
  p1f = subset_taxa(physeq, Phylum %in% c("Firmicutes"))
  mphyseq = psmelt(p1f)
  mphyseq <- subset(mphyseq, Abundance > 0)
  ggplot(data = mphyseq, mapping = aes_string(x = "sex",y = "Abundance",
                              color = Color, fill = Color)) +
    geom_violin(fill = NA) +
    geom_point(size = 1, alpha = 0.3,
               position = position_jitter(width = 0.3)) +
    facet_wrap(facets = Facet) + scale_y_log10()+
    theme(legend.position="none")
}
```
La transformation dans ce cas convertit les dénombrements de chaque échantillon en leurs fréquences, souvent appelées proportions ou abondances relatives . Cette fonction est si simple qu'il est plus facile de la définir dans l'appel de fonction à transform_sample_counts().


```{r}
# Transform to relative abundance. Save as new object.
ps3ra = transform_sample_counts(ps3, function(x){x / sum(x)})
```

#Traçer les valeurs d'abondance avant et après la transformation.
```{r}
plotBefore = plot_abundance(ps3,"")
plotAfter = plot_abundance(ps3ra,"")
# Combine each plot into one graphic.
grid.arrange(nrow = 2,  plotBefore, plotAfter)
```
Le graphique montre une comparaison de l'abondance d'origine (en haut) et de l'abondance relative (en bas). et on peut remarquer que apres la transformation qu'il y'a pas une drande diffrence de valeurs d'abondance dans les 2sexs d'hote


#Sous-ensemble par taxonomie
##sous-ensembles avec la fonction, puis spécifions un rang taxonomique plus précis à l'argument de la fonction que nous avons définie ci-dessus.
```{r}
psOrd = subset_taxa(ps3ra, Order == "Lactobacillales")
plot_abundance(psOrd, Facet = "Genus", Color = NULL)
```

La figure montre l'abondance relative des bactéries classées Lactobacillus par sexe et genre d'hôte. Ici, il est évident que dans le graphique précédent, la distribution biomorphologique évidente de Lactobacillus est le résultat d'un mélange de deux genres différents, et l'abondance relative des Lactobacillus typiques est beaucoup plus grande que celle de Streptococcus.


#Installer quelques packages disponibles pour ces analyses complémentaires
```{r}
.cran_packages <- c( "shiny","miniUI", "caret", "pls", "e1071", "ggplot2", "randomForest", "dplyr", "ggrepel", "nlme", "devtools",
                  "reshape2", "PMA", "structSSI", "ade4",
                  "ggnetwork", "intergraph", "scales")
.github_packages <- c("jfukuyama/phyloseqGraphTest")
.bioc_packages <- c("genefilter", "impute")
# Install CRAN packages (if not already installed)
.inst <- .cran_packages %in% installed.packages()
if (any(!.inst)){
  install.packages(.cran_packages[!.inst],repos = "http://cran.rstudio.com/")
}
.inst <- .github_packages %in% installed.packages()
if (any(!.inst)){
  devtools::install_github(.github_packages[!.inst])
}

.inst <- .bioc_packages %in% installed.packages()
if(any(!.inst)){
  source("http://bioconductor.org/biocLite.R")
  biocLite(.bioc_packages[!.inst])
}
```

#Prétraitement
##enregistrer également le nombre total de dénombrements observés dans chaque échantillon et transformer données en logarithme sous forme de transformation de stabilisation de la variance approximative.
```{r}
qplot(sample_data(ps)$age, geom = "histogram",binwidth=20) + xlab("age")
```

La figure  montre que la covariable d'âge appartient à trois grappes distinctes.




```{r}
qplot(log10(rowSums(otu_table(ps))),binwidth=0.2) +
  xlab("Logged counts-per-sample")
```

Ces graphiques préliminaires suggèrent quelques étapes de prétraitement. L'histogramme de la figure précédente motive la création d'une nouvelle variable catégorielle, regroupant l'âge dans l'un des trois pics. L'histogramme de cette figure indique que la transformation Journal (1 + x) peut être suffisante pour normaliser les données d'abondance pour l'analyse exploratoire. En fait, cette conversion n'est pas suffisante à des fins de test, et lors de l'exécution de l'abondance différentielle, nous vous recommandons d'utiliser la conversion de stabilisation de la variance dans DESeq2 via la fonction phyloseq_to_deseq2, voir le tutoriel phyloseq_to_deseq2 ici


# Examiner l'analyse des coordonnées principales (PCoA) avec soit la dissemblance Bray-Curtis sur la distance Unifrac pondérée
```{r}
sample_data(ps)$age_binned <- cut(sample_data(ps)$age,
                          breaks = c(0, 100, 200, 400))
levels(sample_data(ps)$age_binned) <- list(Young100="(0,100]", Mid100to200="(100,200]", Old200="(200,400]")
sample_data(ps)$family_relationship=gsub(" ","",sample_data(ps)$family_relationship)
pslog <- transform_sample_counts(ps, function(x) log(1 + x))
out.wuf.log <- ordinate(pslog, method = "MDS", distance = "wunifrac")
evals <- out.wuf.log$values$Eigenvalues
plot_ordination(pslog, out.wuf.log, color = "age_binned") +
  labs(col = "Binned Age") +
  coord_fixed(sqrt(evals[2] / evals[1]))
```


Le graphique montre que le classement sur les données d'abondance enregistrées révèle des valeurs aberrantes. Il s'agit d'échantillons de femelles 5 et 6 au jour 165, et d'échantillons de mâles 3, 4, 5 et 6 au jour 175. Nous les retirerons car nous nous intéressons principalement à la relation entre les non-valeurs aberrantes.


#Vérifier les deux valeurs aberrantes féminines - elles ont été reprises par le même OTU / ASV, qui a une abondance relative de plus de 90% dans chacune d'elles.
```{r}
rel_abund <- t(apply(otu_table(ps), 1, function(x) x / sum(x)))
qplot(rel_abund[, 12], geom = "histogram",binwidth=0.05) +
  xlab("Relative abundance")
```



#Différentes projections d'ordination
##calculer les ordinations avec ces valeurs aberrantes supprimées et étudier plus attentivement la sortie.
```{r}
outliers <- c("F5D165", "F6D165", "M3D175", "M4D175", "M5D175", "M6D175")
ps <- prune_samples(!(sample_names(ps) %in% outliers), ps)
```

##supprimer les échantillons avec moins de 1000 lectures:
```{r}
which(!rowSums(otu_table(ps)) > 1000)
```


```{r}
ps <- prune_samples(rowSums(otu_table(ps)) > 1000, ps)
pslog <- transform_sample_counts(ps, function(x) log(1 + x))
```

##effectuer un PCoA en utilisant la dissemblance Bray-Curtis
```{r}
out.pcoa.log <- ordinate(pslog,  method = "MDS", distance = "bray")
evals <- out.pcoa.log$values[,1]
plot_ordination(pslog, out.pcoa.log, color = "age_binned",
                  shape = "family_relationship") +
  labs(col = "Binned Age", shape = "Litter")+
  coord_fixed(sqrt(evals[2] / evals[1]))
```

Sur le graphe, nous voyons un effet d'âge significatif, toutes les souris mâles et femelles et les souris de portées différentes ont le même effet d'âge.

##examiner l'analyse des coordonnées principales doubles (DPCoA) (Pavoine, Dufour et Chessel 2004; Purdom 2010; Fukuyama et al.2012 ) , qui est une méthode d'ordination phylogénétique et qui fournit une représentation biplot des échantillons et des catégories taxonomiques. Nous voyons à nouveau que le deuxième axe correspond aux souris jeunes vs âgées, et le biplot suggère une interprétation du deuxième axe: les échantillons qui ont des scores plus élevés sur le deuxième axe ont plus de taxons de Bacteroidetes et un sous-ensemble de Firmicutes.

```{r}
out.dpcoa.log <- ordinate(pslog, method = "DPCoA")
evals <- out.dpcoa.log$eig
plot_ordination(pslog, out.dpcoa.log, color = "age_binned", label= "SampleID",
                  shape = "family_relationship") +
  labs(col = "Binned Age", shape = "Litter")+
  coord_fixed(sqrt(evals[2] / evals[1]))
```

Sur la figure ci-dessus nous avons le premier axe qui explique 75% de la variabilité, environ 9 fois celle du deuxième axe; cela se traduit par la forme allongée du tracé d'ordination.


#Regarder les résultats du PCoA avec Unifrac pondéré. Comme précédemment, nous constatons que le deuxième axe est associé à un effet d'âge, assez similaire au DPCoA. Cela n'est pas surprenant, car les deux sont des méthodes d'ordination phylogénétique prenant en compte l'abondance.
```{r}
plot_ordination(pslog, out.dpcoa.log, type = "species", color = "Phylum") +
  coord_fixed(sqrt(evals[2] / evals[1]))
```
la figure illustrant les taxons responsables des axes 1 et 2



```{r}
out.wuf.log <- ordinate(pslog, method = "PCoA", distance ="wunifrac")
evals <- out.wuf.log$values$Eigenvalues
plot_ordination(pslog, out.wuf.log, color = "age_binned",
                  shape = "family_relationship") +
  coord_fixed(sqrt(evals[2] / evals[1])) +
  labs(col = "Binned Age", shape = "Litter")
```

Les positions d'échantillon produites par un PCoA utilisant Unifrac pondéré.  Cependant, lorsque nous comparons les biplots, nous voyons que le DPCoA a donné une interprétation beaucoup plus claire du deuxième axe, par rapport à l'Unifrac pondéré.

#PCA sur les rangs
##créer une nouvelle matrice, représentant les abondances par leurs rangs, où le microbe avec le plus petit dans un échantillon est mappé au rang 1, au deuxième rang le plus petit 2, etc.
```{r}
abund <- otu_table(pslog)
abund_ranks <- t(apply(abund, 1, rank))
```
L'utilisation naïve de ces classements pourrait rendre comparables les différences entre les paires de microbes à faible et à forte abondance. Dans le cas où de nombreuses bactéries sont absentes ou présentes à l'état de traces, une différence de rang artificiellement importante pourrait se produire (Holmes et al. 2011) pour les taxons peu abondants. Pour éviter cela, tous les microbes dont le rang est inférieur à un certain seuil doivent être liés à 1. Les rangs des autres microbes sont décalés vers le bas, il n'y a donc pas de grand écart entre les rangs.

```{r}
abund_ranks <- abund_ranks - 329
abund_ranks[abund_ranks < 1] <- 1
```



```{r}
library(dplyr)
library(reshape2)
abund_df <- melt(abund, value.name = "abund") %>%
  left_join(melt(abund_ranks, value.name = "rank"))
colnames(abund_df) <- c("sample", "seq", "abund", "rank")

abund_df <- melt(abund, value.name = "abund") %>%
  left_join(melt(abund_ranks, value.name = "rank"))
colnames(abund_df) <- c("sample", "seq", "abund", "rank")

sample_ix <- sample(1:nrow(abund_df), 8)
ggplot(abund_df %>%
         filter(sample %in% abund_df$sample[sample_ix])) +
  geom_point(aes(x = abund, y = rank, col = sample),
             position = position_jitter(width = 0.2), size = 1.5) +
  labs(x = "Abundance", y = "Thresholded rank") +
  scale_color_brewer(palette = "Set2")
```
La transformation est illustrée dans la figure: la corrélation entre l'abondance et le rang de plusieurs échantillons sélectionnés au hasard. Le numéro de l'axe Dey est le numéro fourni à la PCA.


#Effectuer une PCA et étudier le biplot résultant, donné dans la figure ci-dessous. Pour produire une annotation pour cette figure, nous avons utilisé le bloc suivant.

```{r}
library(ade4)
ranks_pca <- dudi.pca(abund_ranks, scannf = F, nf = 3)
row_scores <- data.frame(li = ranks_pca$li,
                         SampleID = rownames(abund_ranks))
col_scores <- data.frame(co = ranks_pca$co,
                         seq = colnames(abund_ranks))
tax <- tax_table(ps) %>%
  data.frame(stringsAsFactors = FALSE)
tax$seq <- rownames(tax)
main_orders <- c("Clostridiales", "Bacteroidales", "Lactobacillales",
                 "Coriobacteriales")
tax$Order[!(tax$Order %in% main_orders)] <- "Other"
tax$Order <- factor(tax$Order, levels = c(main_orders, "Other"))
tax$otu_id <- seq_len(ncol(otu_table(ps)))
row_scores <- row_scores %>%
  left_join(sample_data(pslog))
col_scores <- col_scores %>%
  left_join(tax)
```



```{r}
evals_prop <- 100 * (ranks_pca$eig / sum(ranks_pca$eig))
ggplot() +
  geom_point(data = row_scores, aes(x = li.Axis1, y = li.Axis2), shape = 2) +
  geom_point(data = col_scores, aes(x = 25 * co.Comp1, y = 25 * co.Comp2, col = Order),
             size = .3, alpha = 0.6) +
  scale_color_brewer(palette = "Set2") +
  facet_grid(~ age_binned) +
  guides(col = guide_legend(override.aes = list(size = 3))) +
  labs(x = sprintf("Axis1 [%s%% variance]", round(evals_prop[1], 2)),
       y = sprintf("Axis2 [%s%% variance]", round(evals_prop[2], 2))) +
  coord_fixed(sqrt(ranks_pca$eig[2] / ranks_pca$eig[1])) +
  theme(panel.border = element_rect(color = "#787878", fill = alpha("white", 0)))
```

Le résultat est similaire à l'analyse PCoA calculée sans appliquer la transformation de classement raccourcie, augmentant ainsi notre confiance dans l'analyse des données d'origine.



#Pour utiliser des échantillons de données supplémentaires, il est nécessaire de fournir un argument supplémentaire, spécifiant les caractéristiques à prendre en compte - sinon, par défaut, toutes les mesures sont utilisées lors de la production de l'ordination.
```{r}
ps_ccpna <- ordinate(pslog, "CCA", formula = pslog ~ age_binned + family_relationship)
```


#afin d'accéder aux positions du biplot, nous pouvons utiliser la fonction ordinatedans phyloseq. De plus, pour faciliter l'annotation des figures, nous joignons également les scores du site avec les données environnementales dans la fente. .
```{r}
library(ggrepel)
ps_scores <- vegan::scores(ps_ccpna)
sites <- data.frame(ps_scores$sites)
sites$SampleID <- rownames(sites)
sites <- sites %>%
  left_join(sample_data(ps))

species <- data.frame(ps_scores$species)
species$otu_id <- seq_along(colnames(otu_table(ps)))
species <- species %>%
  left_join(tax)
evals_prop <- 100 * ps_ccpna$CCA$eig[1:2] / sum(ps_ccpna$CA$eig)
ggplot() +
  geom_point(data = sites, aes(x = CCA1, y = CCA2), shape = 2, alpha = 0.5) +
  geom_point(data = species, aes(x = CCA1, y = CCA2, col = Order), size = 0.5) +
  geom_text_repel(data = species %>% filter(CCA2 < -2),
                    aes(x = CCA1, y = CCA2, label = otu_id),
            size = 1.5, segment.size = 0.1) +
  facet_grid(. ~ family_relationship) +
  guides(col = guide_legend(override.aes = list(size = 3))) +
  labs(x = sprintf("Axis1 [%s%% variance]", round(evals_prop[1], 2)),
        y = sprintf("Axis2 [%s%% variance]", round(evals_prop[2], 2))) +
  scale_color_brewer(palette = "Set2") +
  coord_fixed(sqrt(ps_ccpna$CCA$eig[2] / ps_ccpna$CCA$eig[1])*0.45   ) +
  theme(panel.border = element_rect(color = "#787878", fill = alpha("white", 0)))
```

Les scores souris et bactéries générés par CCpnA. Sur les 23 ordres taxonomiques totaux, nous n'annotons explicitement que les quatre plus abondants Clostridiales, Bacteroidales, Lactobacillales,Coriobacteriales- cela rend le biplot plus facile à lire

#Enseignement supervisé
## illustrer quelques méthodes d'apprentissage supervisé qui peuvent être facilement exécutées dans R. Diviser les données en ensembles d'apprentissage et de test, les affectations étant effectuées à la souris plutôt que par échantillon,

```{r}
library(caret)
sample_data(pslog)$age2 <- cut(sample_data(pslog)$age, c(0, 100, 400))
dataMatrix <- data.frame(age = sample_data(pslog)$age2, otu_table(pslog))
# take 8 mice at random to be the training set, and the remaining 4 the test set
trainingMice <- sample(unique(sample_data(pslog)$host_subject_id), size = 8)
inTrain <- which(sample_data(pslog)$host_subject_id %in% trainingMice)
training <- dataMatrix[inTrain,]
testing <- dataMatrix[-inTrain,]
plsFit <- train(age ~ ., data = training,
                method = "pls", preProc = "center")
```

##Prédire les étiquettes de classe sur l'ensemble de test en utilisant la fonction predictet comparer à la vérité. Nous voyons que la méthode fait un excellent travail de prédiction de l'âge.
```{r}
plsClasses <- predict(plsFit, newdata = testing)
table(plsClasses, testing$age)
```
Comme autre exemple, nous pouvons essayer des forêts aléatoires. Ceci est exécuté exactement de la même manière que PLS, en basculant l'argument de à. Les forêts aléatoires se comportent également bien à la tâche de prédiction sur cet ensemble de test, bien qu'il y ait plus de vieilles souris mal classées comme jeunes.

```{r}
library(randomForest)
rfFit <- train(age ~ ., data = training, method = "rf",
               preProc = "center", proximity = TRUE)
rfClasses <- predict(rfFit, newdata = testing)
table(rfClasses, testing$age)
```
Pour interpréter ces PLS et les résultats aléatoires de la forêt, il est standard de produire respectivement des biplots et des graphiques de proximité. Le code ci-dessous extrait les coordonnées et fournit des annotations pour les points à inclure sur le biplot PLS.

#To interpret these PLS and random forest results, it is standard to produce biplots and proximity plots, respectively. The code below extracts coordinates and supplies annotation for points to include on the PLS biplot.

```{r}
library(vegan)
library(phyloseq)
library(dplyr)
pls_biplot <- list("loadings" = loadings(plsFit$finalModel),
                   "scores" = scores(plsFit$finalModel))
class(pls_biplot$scores) <- "matrix"

pls_biplot$scores <- data.frame(sample_data(pslog)[inTrain, ],
                                pls_biplot$scores)

tax <- tax_table(ps)@.Data %>% data.frame(stringsAsFactors = FALSE)
main_orders <- c("Clostridiales", "Bacteroidales", "Lactobacillales",
                 "Coriobacteriales")
tax$Order[!(tax$Order %in% main_orders)] <- "Other"
tax$Order <- factor(tax$Order, levels = c(main_orders, "Other"))
class(pls_biplot$loadings) <- "matrix"
pls_biplot$loadings <- data.frame(tax, pls_biplot$loadings)
```

```{r}
library(viridisLite)
ggplot() +
  geom_point(data = pls_biplot$scores,
             aes(x = Comp.1, y = Comp.2), shape = 2) +
  geom_point(data = pls_biplot$loadings,
             aes(x = 25 * Comp.1, y = 25 * Comp.2, col = Order),
             size = 0.3, alpha = 0.6) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Axis1", y = "Axis2", col = "Binned Age") +
  guides(col = guide_legend(override.aes = list(size = 3))) +
  facet_grid( ~ age2) +
  theme(panel.border = element_rect(color = "#787878", fill = alpha("white", 0)))
```

Le graphique à deux lignes généré est illustré dans la figure. Il peut être expliqué de la même manière que le graphique de Pareto précédent, sauf que la variable d'âge combinée doit être explicitement citée lors du choix de la projection. Plus précisément, le PLS identifie le sous-espace pour distinguer les catégories dans la plus grande mesure, et le double graphique affiche la projection d'échantillon et les coefficients ASV par rapport au sous-espace.


```{r}
rf_prox <- cmdscale(1 - rfFit$finalModel$proximity) %>%
  data.frame(sample_data(pslog)[inTrain, ])

ggplot(rf_prox) +
  geom_point(aes(x = X1, y = X2, col = age_binned),
             size = 1, alpha = 0.7) +
  scale_color_manual(values = c("#A66EB8", "#238DB5", "#748B4F")) +
  guides(col = guide_legend(override.aes = list(size = 4))) +
  labs(col = "Binned Age", x = "Axis1", y = "Axis2")
```
Le double graphique résultant est présenté à la figure 17. Il peut être expliqué de la même manière que le graphique de Pareto précédent, sauf que la variable d'âge combinée doit être explicitement citée lors du choix de la projection. Plus précisément, le PLS identifie le sous-espace pour distinguer les catégories dans la plus grande mesure, et le double graphique affiche la projection d'échantillon et les coefficients ASV par rapport au sous-espace.


```{r}
as.vector(tax_table(ps)[which.max(importance(rfFit$finalModel)), c("Family", "Genus")])
```

```{r}
impOtu <- as.vector(otu_table(pslog)[,which.max(importance(rfFit$finalModel))])
maxImpDF <- data.frame(sample_data(pslog), abund = impOtu)
ggplot(maxImpDF) +   geom_histogram(aes(x = abund)) +
  facet_grid(age2 ~ .) +
  labs(x = "Abundance of discriminative bacteria", y = "Number of samples")
```

Afin de mieux comprendre le modèle forestier aléatoire ajusté, nous avons identifié les micro-organismes qui ont la plus grande influence sur la prédiction aléatoire des forêts. C'est un microorganisme de la famille des Lachnospiracées et du genre Roseburia. La figure 19 montre son abondance dans l'échantillon; on voit que de 0 à 100 jours, elle est toujours très faible, et de 100 à 400 jours, elle est très élevée.

#Analyses basées sur des graphiques
##Créer et tracer des graphiques: tracer le réseau avec la coloration à la souris et la forme à la litière.
```{r}
library("phyloseqGraphTest")
library("igraph")
library("ggnetwork")
net <- make_network(ps, max.dist=0.35)
sampledata <- data.frame(sample_data(ps))
V(net)$id <- sampledata[names(V(net)), "host_subject_id"]
V(net)$litter <- sampledata[names(V(net)), "family_relationship"]

net_graphe <- ggnetwork(net)

ggplot(net_graphe, aes(x = x, y = y, xend = xend, yend = yend), layout = "fruchtermanreingold") +
  geom_edges(color = "darkgray") +
  geom_nodes(aes(color = id, shape = litter),  size = 3 ) +
  theme(axis.text = element_blank(), axis.title = element_blank(),
        legend.key.height = unit(0.5,"line")) +
  guides(col = guide_legend(override.aes = list(size = .5)))

```

Nous voyons le réseau généré sur la figure. La couleur de la figure indique la souris échantillonnée, et la forme indique la portée de la souris. Nous pouvons voir un ensemble d'échantillons triés par souris et déchets.

#Tests à deux échantillons basés sur des graphiques
##Arbre couvrant minimum (MST)
```{r}
gt <- graph_perm_test(ps, "family_relationship", grouping = "host_subject_id",
                      distance = "jaccard", type = "mst")
gt$pva
```

```{r}
library(gridExtra)
plotNet1=plot_test_network(gt) + theme(legend.text = element_text(size = 8),
        legend.title = element_text(size = 9))
plotPerm1=plot_permutations(gt)
grid.arrange(ncol = 2,  plotNet1, plotPerm1)
```
Le graphe et l'histogramme de permutation obtenus à partir de l'arbre couvrant minimal avec similitude Jaccard. La p-value de ce test est petite et nous rejetons l'hypothèse nulle que les deux échantillons proviennent de la même distribution. À partir du diagramme en arbre couvrant minimum de la figure, nous pouvons voir à l'œil nu que le nombre d'échantillons classés comme déchets est supérieur à ce que nous avons vu par accident.afin de comparer la composition des echantillions par rapport à la ligne des souris.


#Voisins les plus proches
```{r}
gt <- graph_perm_test(ps, "family_relationship", grouping = "host_subject_id",
                      distance = "jaccard", type = "knn", knn = 1)
```



```{r}
plotNet2=plot_test_network(gt) + theme(legend.text = element_text(size = 8),
        legend.title = element_text(size = 9))
plotPerm2=plot_permutations(gt)
grid.arrange(ncol = 2,  plotNet2, plotPerm2)
```

la figure  donne le réseau voisin le plus proche et histogramme organisé. On peut voir sur la figure ci-dessus que si une paire d'échantillons a un bord entre eux dans le graphique du plus proche voisin, ils sont très probablement dans la même plage.


#Modélisation linéaire
##calculons d'abord la diversité de Shannon associée à chaque échantillon et la joignons avec l'annotation d'échantillon.
```{r}
library("nlme")
library("reshape2")
ps_alpha_div <- estimate_richness(ps, split = TRUE, measure = "Shannon")
ps_alpha_div$SampleID <- rownames(ps_alpha_div) %>%
  as.factor()
ps_samp <- sample_data(ps) %>%
  unclass() %>%
  data.frame() %>%
  left_join(ps_alpha_div, by = "SampleID") %>%
  melt(measure.vars = "Shannon",
       variable.name = "diversity_measure",
       value.name = "alpha_diversity")

# reorder's facet from lowest to highest diversity
diversity_means <- ps_samp %>%
  group_by(host_subject_id) %>%
  summarise(mean_div = mean(alpha_diversity)) %>%
  arrange(mean_div)
ps_samp$host_subject_id <- factor(ps_samp$host_subject_id)
#                                  diversity_means$host_subject_id)
```

```{r}
alpha_div_model <- lme(fixed = alpha_diversity ~ age_binned, data = ps_samp,
                       random = ~ 1 | host_subject_id)
```


```{r}
new_data <- expand.grid(host_subject_id = levels(ps_samp$host_subject_id),
                        age_binned = levels(ps_samp$age_binned))
new_data$pred <- predict(alpha_div_model, newdata = new_data)
X <- model.matrix(eval(eval(alpha_div_model$call$fixed)[-2]),
                  new_data[-ncol(new_data)])
pred_var_fixed <- diag(X %*% alpha_div_model$varFix %*% t(X))
new_data$pred_var <- pred_var_fixed + alpha_div_model$sigma ^ 2
```


```{r}
ggplot(ps_samp %>% left_join(new_data)) +
  geom_errorbar(aes(x = age_binned, ymin = pred - 2 * sqrt(pred_var),
                    ymax = pred + 2 * sqrt(pred_var)),
                col = "#858585", size = .1) +
  geom_point(aes(x = age_binned, y = alpha_diversity,
                 col = family_relationship), size = 0.8) +
  facet_wrap(~host_subject_id) +
  scale_y_continuous(limits = c(2.4, 4.6), breaks = seq(0, 5, .5)) +
  scale_color_brewer(palette = "Set2") +
  labs(x = "Binned Age", y = "Shannon Diversity", color = "Litter") +
  guides(col = guide_legend(override.aes = list(size = 4))) +
  theme(panel.border = element_rect(color = "#787878", fill = alpha("white", 0)),
        axis.text.x = element_text(angle = -90, size = 6),
        axis.text.y = element_text(size = 6))
```

Le but de cette analyse n'est pas de développer de nombreuses bactéries liées aux caractéristiques de l'échantillon. Il s'agit plutôt de la manière dont une seule mesure décrivant la structure globale de la communauté est liée aux caractéristiques de l'échantillon. Il s'agit d'un objectif statistique légèrement plus simple qui peut être atteint par la modélisation linéaire. Pour cela, il existe plusieurs méthodes dans R. Par exemple, nous utiliserons un modèle à effets mixtes pour étudier la relation entre la diversité de la communauté microbienne de la souris et les variables d'âge et de plage jusqu'à présent. Il a été observé que la diversité Shannon des souris plus jeunes était significativement plus faible, mais que différentes souris avaient une diversité de base différente, ce qui a incité ce choix. Le modèle à effets mixtes est le point de départ pour formaliser cette observation.

#Hierarchical multiple testing
##identifier les microbes individuels dont l'abondance est liée à des variables d'échantillons d'intérêt. Une approche standard consiste à calculer une statistique de test pour chaque bactérie individuellement, à mesurer son association avec les caractéristiques de l'échantillon, puis à ajuster conjointementp-valeurs pour garantir une limite supérieure de False Discovery Rate
```{r}
library("reshape2")
library("DESeq2")
#New version of DESeq2 needs special levels
sample_data(ps)$age_binned <- cut(sample_data(ps)$age,
                          breaks = c(0, 100, 200, 400))
levels(sample_data(ps)$age_binned) <- list(Young100="(0,100]", Mid100to200="(100,200]", Old200="(200,400]")
sample_data(ps)$family_relationship = gsub(" ", "", sample_data(ps)$family_relationship)
ps_dds <- phyloseq_to_deseq2(ps, design = ~ age_binned + family_relationship)

# geometric mean, set to zero when all coordinates are zero
geo_mean_protected <- function(x) {
  if (all(x == 0)) {
    return (0)
  }
  exp(mean(log(x[x != 0])))
}

geoMeans <- apply(counts(ps_dds), 1, geo_mean_protected)
ps_dds <- estimateSizeFactors(ps_dds, geoMeans = geoMeans)
ps_dds <- estimateDispersions(ps_dds)
abund <- getVarianceStabilizedData(ps_dds)
```



```{r}
short_names <- substr(rownames(abund), 1, 5)%>%
  make.names(unique = TRUE)
rownames(abund) <- short_names
```



```{r}
abund_sums <- rbind(data.frame(sum = colSums(abund),
                               sample = colnames(abund),
                               type = "DESeq2"),
                    data.frame(sum = rowSums(otu_table(pslog)),
                               sample = rownames(otu_table(pslog)),
                               type = "log(1 + x)"))

ggplot(abund_sums) +
  geom_histogram(aes(x = sum), binwidth = 20) +
  facet_grid(type ~ .) +
  xlab("Total abundance within sample")
```
C'est la motivation pour utiliser cette conversion, bien que pour des dénombrements d'abondance élevés, elle soit équivalente logarithmique; pour des abondances faibles et moyennes, elle n'écrasera pas les données et ne donnera pas de meilleurs résultats. puissant. Le code suivant illustre le mécanisme de calcul de la transformation de stabilisation de la variance sur l'objet.

#La procédure de test hiérarchique nécessite des tests univariés pour chaque groupe taxonomique de niveau supérieur, pas seulement pour toutes les espèces. Une fonction d'assistance,, treePValuesest disponible pour cela; il attend une edgelist encodant les relations parent-enfant, la première ligne spécifiant le nœud racine.
```{r}
library("structSSI")
el <- phy_tree(pslog)$edge
el0 <- el
el0 <- el0[nrow(el):1, ]
el_names <- c(short_names, seq_len(phy_tree(pslog)$Nnode))
el[, 1] <- el_names[el0[, 1]]
el[, 2] <- el_names[as.numeric(el0[, 2])]
unadj_p <- treePValues(el, abund, sample_data(pslog)$age_binned)
```


#corriger p-valeur en utilisant la procédure de test hiérarchique. Les résultats des tests sont garantis pour contrôler plusieurs variantes de contrôle FDR, mais à des niveaux différents; nous reportons les détails à (Benjamini et Yekutieli 2003; Benjamini et Bogomolov 2014; Sankaran et Holmes 2014) .
```{r}
hfdr_res <- hFDR.adjust(unadj_p, el, .75)
summary(hfdr_res)
```

##interactive part: not run
```{r}
plot(hfdr_res, height = 5000)
```

#En parcourant l'arbre complet, il devient clair que l'association entre le groupe d'âge et l'abondance bactérienne n'est présente que dans quelques groupes taxonomiques isolés, mais qu'elle est assez forte dans ces groupes. Pour contextualiser ces résultats, nous pouvons retrouver l'identité taxinomique des hypothèses rejetées.
```{r}
tax <- tax_table(pslog)[, c("Family", "Genus")] %>%
  data.frame()
tax$seq <- short_names
```

```{r}
options(digits=3)
hfdr_res@p.vals$seq <- rownames(hfdr_res@p.vals)
tax %>%
  left_join(hfdr_res@p.vals) %>%
  arrange(adjp) %>% head(10)
```
Il semble que les bactéries les plus fortement associées appartiennent toutes à la famille des Lachnospiracées , ce qui est cohérent avec les résultats aléatoires de la forêt.



#Techniques polyvalentes

```{r}
metab <- read.csv("https://raw.githubusercontent.com/spholmes/F1000_workflow/master/data/metabolites.csv",row.names = 1)
microbe_connect <-url("https://raw.githubusercontent.com/spholmes/F1000_workflow/master/data/microbe.rda")
load(microbe_connect)
microbe
```
Nous voyons que microbec'est un phyloseqobjet. Notre prétraitement reflète celui des données de la souris. Nous filtrons d'abord les microbes et les métabolites d'intérêt, en supprimant ceux qui sont nuls sur de nombreux échantillons. Ensuite, nous les transformons pour affaiblir les queues lourdes. Nous prenons également le journal des métabolites.


#Appliquer une CCA clairsemée. Cette méthode compare des ensembles d'entités dans des tables de données de grande dimension, où il peut y avoir plus d'entités mesurées que d'échantillons. 
```{r}
library("genefilter")
keep_ix <- rowSums(metab == 0) <= 3
metab <- metab[keep_ix, ]
microbe <- prune_taxa(taxa_sums(microbe) > 4, microbe)
microbe <- filter_taxa(microbe, filterfun(kOverA(3, 2)), TRUE)
metab <- log(1 + metab, base = 10)
X <- otu_table(microbe)
X[X > 50] <- 50
dim(X)
```

```{r}
dim(metab)
```

#ppliquer une CCA clairsemée. Cette méthode compare des ensembles d'entités dans des tables de données de grande dimension, où il peut y avoir plus d'entités mesurées que d'échantillons
```{r}
library(PMA)
cca_res <- CCA(t(X),  t(metab), penaltyx = .15, penaltyz = .15)
```

```{r}
cca_res
```
#utiliser ces 20 fonctionnalités pour compresser les informations des deux tables sans trop de pertes. Pour relier les métabolites et OTU récupérés aux caractéristiques des échantillons sur lesquels ils ont été mesurés, nous les utilisons comme intrants dans un PCA ordinaire.
```{r}
combined <- cbind(t(X[cca_res$u != 0, ]),
                  t(metab[cca_res$v != 0, ]))
pca_res <- dudi.pca(combined, scannf = F, nf = 3)
```


```{r}
genotype <- substr(rownames(pca_res$li), 1, 2)
sample_type <- substr(rownames(pca_res$l1), 3, 4)
feature_type <- grepl("\\.", colnames(combined))
feature_type <- ifelse(feature_type, "Metabolite", "OTU")
sample_info <- data.frame(pca_res$li, genotype, sample_type)
feature_info <- data.frame(pca_res$c1,
                           feature = substr(colnames(combined), 1, 6))
```


```{r}
ggplot() +  geom_point(data = sample_info,
            aes(x = Axis1, y = Axis2, col = sample_type, shape = genotype), size = 3) + 
  geom_label_repel(data = feature_info,
                   aes(x = 5.5 * CS1, y = 5.5 * CS2, label = feature, fill = feature_type),
                   size = 2, segment.size = 0.3,
                   label.padding = unit(0.1, "lines"), label.size = 0) +
  geom_point(data = feature_info,
             aes(x = 5.5 * CS1, y = 5.5 * CS2, fill = feature_type),
             size = 1, shape = 23, col = "#383838") +
  scale_color_brewer(palette = "Set2") +
  scale_fill_manual(values = c("#a6d854", "#e78ac3")) +
  guides(fill = guide_legend(override.aes = list(shape = 32, size = 0))) +
  coord_fixed(sqrt(pca_res$eig[2] / pca_res$eig[2])) +
  labs(x = sprintf("Axis1 [%s%% Variance]",
                   100 * round(pca_res$eig[1] / sum(pca_res$eig), 2)),
       y = sprintf("Axis2 [%s%% Variance]",
                   100 * round(pca_res$eig[2] / sum(pca_res$eig), 2)),
       fill = "Feature Type", col = "Sample Type")
```
Triple courbe PCA générée selon les caractéristiques sélectionnées par ACC à partir de plusieurs types de données; métabolites et OTU La figure montre le diagramme à trois coordonnées PCA, qui montre différents types d'échantillons et des caractéristiques multi-domaines (métabolites et OTU). Cela vous permet de comparer les échantillons mesurés (triangles utilisés pour l'abattage et les cercles utilisés pour les types sauvages) et de caractériser l'impact de différentes entités (losanges avec des étiquettes de texte). Par exemple, nous voyons que le principal changement de données se situe entre les échantillons PD et ST, ce qui correspond à des scénarios différents.
En outre, de grandes valeurs de 15 des caractéristiques sont associées à l'état ST, tandis que de petites valeurs pour 5 d'entre elles indiquent l'état PD. L'avantage du criblage CCA clairsemé est maintenant clair: nous pouvons afficher la plupart des variations entre les échantillons à l'aide d'un tracé relativement simple, et pouvons éviter de tracer les centaines de points supplémentaires qui seraient nécessaires pour afficher toutes les caractéristiques.



```{r}
devtools::session_info()
```

```{r}
save.image (file = "my_work_space.RData")
```

```{r}
load("my_work_space.RData")
library (tidyverse)
```


